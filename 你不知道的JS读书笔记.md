## 第一部分  作用域和闭包

#### 第一章 作用域是什么

##### 1.编译原理：

JavaScript（即时编译）:一门编译语言，但与传统编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中进行移植。尽管如此，JS引擎进行编译的步骤和传统编译语言非常相似，在某些环节可能比预想的要复杂。

传统编译语言的流程中：分为三部分：

分词/词法分析（分解成词法单元）——解析/语法分析（词法单元流转化为抽象语法树AST）——代码生成（AST转换为可执行代码）

##### 2.理解作用域：（编译器，引擎，作用域）

``` js
var a=2;//在编译时声明，在执行时赋值
```

赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

引擎查找类型：（赋值操作的左右，不一定是=的左右）

LHS：当变量出现在赋值操作的左侧时进行LHS查询，即试图找到变量的容器本身，从而可以对其赋值

RHS：变量出现在右侧时，RHS查询即简单的查找某个变量的值。（“非左侧”）可以理解为取到它的源值

编译器可以在代码生成的同时处理声明和值的定义（编译时声明函数，不需要在执行时进行LHS引用）

##### 3.作用域嵌套

作用域：是根据名称查找变量的一套规则，规定了当前代码对某个变量的使用权限

##### 4.异常

如果RHS查询在所有嵌套的作用域中都遍寻不到所需的变量，引擎就会抛出ReferenceError异常。

如果RHS查询到了一个变量，但你对该值进行了不合理的操作，引擎会抛出TyprError操作。

而LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在“非严格模式”下。

（严格模式（ES5引入）下，LHS查询失败不会创建全局变量，会抛出ReferenceError异常）

#### 第二章，词法作用域

作用域主要有两种工作模型：**词法作用域**（JS及大部分编程语言所采用）和动态作用域

##### 1.词法阶段

词法作用域就是定义在词法阶段的作用域，换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由被声明时所处的位置决定

##### 2.欺骗词法：动态修改词法作用域或动态创建新的词法作用域

**2.1 eval()**

接受一个字符串为参数，并将其中的内容视为好像书写时就存在于程序中这个位置的代码，可以在运行期修改书写期的词法作用域

**2.2 with(obj)**

with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符

**eval()函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with()声明实际上是根据你传给它的对象凭空创建了一个新的词法作用域**

**为什么不推荐使用eval()和with()?**

(1)欺骗词法会导致性能下降

(2)会被严格模式所限制，with被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval()也被禁止了

**2.3 性能**

为什么会导致性能下降？

JS引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了eval()和with()，在悲观情况下可能会做不到任何优化。

**引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的**

#### 第三章 函数作用域和块作用域

##### 1.函数中的作用域

##### 2.隐藏内部实现

##### 3.函数作用域

##### 4.块作用域

#### 第四章 提升

##### 1.先有鸡还是先有蛋

##### 2.编译器再度来袭

##### 3.函数优先

#### 第五章 作用域闭包

##### 1.启示

##### 2.实质问题

##### 3.现在我懂了

##### 4.循环和闭包

##### 5.模块



## 第二部分 this和对象原型





