### 1.let和const:

#### 1.1 let 和 var 的区别：

（1）let有块作用域，所声明的变量只在let命令所在的代码块内有效（for循环：*JavaScript引擎内部可以记住上一次循环的值*）

（2）let不存在变量提升：let:报错ReferenceError  var:输出undefined

（3）let暂时性死区：ES6 明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。“暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作。

（4）let不允许在相同作用域内重复声明同一个变量

#### 1.2 const命令

（1）`const`声明的变量不得改变值，这意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值。

（2）`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效

（3）const命令声明的常量也不提升，也存在暂时性死区

（4）const声明的常量同样不可以重复声明

`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于将对象声明为常量，该常量所存储的地址不能变，但对象本身可以变。可以用Object.freeze()方法将对象冻结

#### 1.3 声明变量的六种方法：

var,function,let,const,*import和class*

#### 1.4 顶层对象的属性

浏览器：顶层对象：window对象

Node:顶层对象：global对象

**ES5中顶层对象的属性和全局变量是等价的**

ES6 为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

#### 1.5 globalThis对象（stage3）

### 2.变量的解构赋值

#### 2.1 数组的解构赋值

只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值，如数组结构，Set结构

#### 2.2 对象的解构赋值

对象的解构与数组有一个重要的不同，数组的元素是按次序排列的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。





