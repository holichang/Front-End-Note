## 一.相关知识点

#### 1.渐进式框架：

没有强主张，没有多做职责之外的事

#### 2.前端工程化：

[原文](https://www.cnblogs.com/ihardcoder/p/5378290.html)

##### 2.1 前端工程化，面临的问题是如何提高**编码->测试->维护**阶段的生产效率

##### 2.2 要解决前端工程化的问题，可以从两个角度入手：**开发**和**部署**。

从**开发角度**，要解决的问题包括：

（1）提高开发生产效率；

（2）降低维护难度。

这两个问题的解决方案有两点：

（1）制定开发规范，提高团队协作能力；

（2）分治。软件工程中有个很重要的概念叫做**模块化开发**其中心思想就是分治。

从**部署角度**，要解决的问题主要是**资源管理**，包括：

（1）代码审查；

（2）压缩打包；

（3）增量更新；

（4）单元测试；

**模块化开发：**模块白盒，组件黑盒。颗粒度不同

##### 2.3 构建&编译

2016年节点下，一个典型的web前后端协作模式如下图：

![img](https://images2015.cnblogs.com/blog/595796/201604/595796-20160411142716207-1803317219.png)

**大前端模式下：**

![img](https://images2015.cnblogs.com/blog/595796/201604/595796-20160411142733598-1823214206.png)

大前端体系下，前端开发人员掌握着Node.js搭建的web server层。与上文提到的常规前端开发体系下相比，省略了mock server的角色，但是构建在大前端体系下的作用并没有发生改变。也就是说，不论是大前端还是“小”前端，构建阶段在两种模式下的作用完全一致，**构建的作用就是对静态资源以及模板进行处理**，换句话说：**构建的核心是资源管理**。

**什么是资源管理？**

前端的资源可以分为**静态资源**和**模板**。模板对静态资源是引用关系，两者相辅相成，构建过程中需要对两种资源使用不同的构建策略。

静态资源包括js、css、图片等文件，目前随着一些新规范和css预编译器的普及，通常开发阶段的静态资源是：

1. es6/7规范的文件；
2. less/sass等文件（具体看团队技术选型）；
3. [可选]独立的小图标，在构建阶段使用工具处理成spirit图片。

构建可以分为**工具层面**和**平台层面**的功能：

- 工具层面

1. 预编译，包括es6/7语法转译（比如babel）、css预编译器处理（如将less/sass编译成css）、spirit图片生成；
2. 依赖打包。分析文件依赖关系，将同步依赖的的文件打包在一起，减少http请求数量；
3. 资源嵌入。比如小于10KB的图片编译为base64格式嵌入文档，减少一次http请求；
4. 文件压缩。减小文件体积；
5. hash指纹。通过给文件名加入hash指纹，以应对浏览器缓存引起的静态资源更新问题；
6. 代码审查。避免上线文件的低级错误；
7. 模板构建。

- 平台层面

1. 文件监听。配合动态构建、浏览器自动刷新等功能，提高开发效率；
2. mock server。并非所有前端团队都是大前端（事实上很少团队是大前端），即使在大前端体系下，mock server的存在也是很有必要的；

##### 2.4 总结;

一个完整的前端工程体系应该包括：

（1）统一的开发规范；

（2）组件化开发；

（3）构建流程。

#### 3.脚手架

简易前端工作流如下：

![1569339963707](C:\Users\凌多\AppData\Roaming\Typora\typora-user-images\1569339963707.png)

脚手架：作用是创建项目的初始文件,**让项目从"搭建-开发-部署"更加快速以及规范**，前端脚手架的实质包含两项，命令式的构建项目（解析命令，拷贝项目到本地），提供项目的配置（构建，编译，代码规范检查）,同时应具备高度可扩展性

#### 4.构建

- Gulp,Grunt（重在规范前端开发流程，并不强调模块化）：集成度不高，要写很多配置后才可以用，无法做到开箱即用。相比于Grunt,Gulp增加了监听文件、读写文件、流式处理的功能。

- fis:百度开发的，配置简单、开箱即用、内置了许多功能，无需做太多配置就能完成大量工作

- webpack（重在模块化开发，文件压缩，预编译等功能只是附带的）：Webpack（https://webpack.js.org） 是一个打包模块化JavaScript的工具，在Webpack里一切文件皆模块，通过Loader转换文件，通过Plugin注入钩子，最后输出由多个模块组合成的文件。Webpack专注于构建模块化项目。

  优点：专注于处理模块化的项目，能做到开箱即用、一步到位；可通过Plugin扩展，完整好用又不失灵活；使用场景不局限于Web开发；社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；良好的开发体验。

  缺点：只能用于采用模块化开发的项目。

#### 5.less、sass、scss

less 和 sass 是两种 css 预编译语言，就是说通过 less 或者 scss 写的代码最终都会被编译成 css 再使用。其目的是为了更快、更结构的编写 css 文件，都能使用 变量、运算符、判断、方法等等。

scss 与 sass 的区别：

先有的 sass 后有的 scss
scss 需要大括号{}和分号;
sass 什么都不用直接裸奔，通过缩进来区分代码等级，像 yaml 语言

#### 6.MVC、MVP、MVVM

**6.1 MVC**

MVC模式软件可以分为三个部分:View（用户界面）,Controller（业务逻辑）,Model（数据保存）,但这三个部分没有明显的界限

各部分之间的通信方式如下：所有通信都是单向的

![MVC](D:\Front-End-Note\image\MVC.png)

**6.2 MVP**

MVP模式将Controller改名为Presenter,同时改变了通信方向：

![MVP](D:\Front-End-Note\image\MVP.png)

- 各部分之间的通信，都是双向的。
-  View 与 Model 不发生联系，都通过 Presenter 传递。
-  View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。

**6.3 MVVM：**Model-View-ViewModle：模型-视图-**视图模型（核心：双向桥梁）**

![MVVM](D:\Front-End-Note\image\MVVM.png)

和MVP唯一的区别是MVVM采用双向绑定，View的变化会自动反映在ViewModel，反之亦然。

【模型】转为【视图】：数据绑定

【视图】转为【模型】：DOM事件监听

在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。

ViewModel存在目的在于抽离Controller中展示的业务逻辑

主流框架实现双向绑定（响应式）：

**（1）脏值检查 **（angular.js）
**（2）观察者-订阅者（数据劫持）**（Vue.js）VueObserver数据监听器

Vue双向绑定原理：

![Vue双向绑定](D:\Front-End-Note\image\Vue双向绑定.jpg)

从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行解析，初始化视图，并订阅Watcher 来更新视图， 此时Watcher 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。因为VUE使用Object.defineProperty方法来做数据绑定，而这个方法又无法通过兼容性处理，所以Vue 不支持 IE8 以及更低版本浏览器。另外，查看vue原代码，发现在vue初始化实例时， **有一个proxy代理方法，它的作用就是遍历data中的属性，把它代理到vm的实例上，这也就是我们可以这样调用属性：vm.aaa等于vm.data.aaa。**

**proxy代理：**

****

## 二. Vue知识点：

**Vue的特点：**

- 渐进式框架：没有强主张，没有做职责之外的事

- 自底向上逐层应用

- 只关注视图层，便于与第三方库或既有项目整合

- 当与**现代化的工具链**以及**各种支持类库**结合使用时，能够为复杂的单页应用提供驱动

  >什么是现代化的工具链？
  >
  >

**对比其它框架：**

>
>
>

Vue不仅可以把数据绑定到DOM文本或attribute，还可以绑定到DOM结构，以及强大的过渡效果系统，可以在Vue插入/更新/移除元素时自动应用过渡效果

v-bind:attr绑定属性，v-if，v-for，v-on:click事件监听，v-model:处理用户输入

### 1. Vue实例

（1）当一个 Vue 实例被创建时，它将 `data` 对象中的所有的 property 加入到 Vue 的**响应式系统**中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。

（2）只有当实例被创建时就已经存在于data中的property才是响应式的。

（3）Vue通过$将Vue的实例property和方法与用户定义的property区分开来。

#### 1.1 实例生命周期钩子：

钩子函数和回调函数：

钩子函数 和 回调函数 一般都可用来处理事件“回调”。

回调函数是你留个处理方法给事件，事件发生了以后会自动执行你留下调处理方法；

钩子函数是好比找了个代理，监视事件是否发生，如果发生了这个代理就执行你的事件处理方法；在这个过程中，代理就是钩子函数；

在某种意义上，回调函数做的处理过程跟钩子函数中要调用调方法一样

但是有一点需要明确： 钩子函数一般是又事件发生者提供的。直白了说，它留下一个钩子，这个钩子的作用就是钩住你的回调方法。

#### 1.2 生命周期图示：

每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。

<img src="D:\Front-End-Note\image\vue生命周期.png" alt="vue生命周期" style="zoom:50%;" />

### 2.模板语法

**虚拟DOM：**相比重排/重绘，javaScript运行速度很快，虚拟DOM是放在JS 和 HTML中间的一个层。它可以通过新旧DOM的对比，来获取对比之后的差异对象，然后有针对性的把差异部分真正地渲染到页面上，从而减少实际DOM操作，最终达到性能优化的目的。

![virtualDOM](D:\Front-End-Note\image\virtualDOM.png)

#### 2.1 插值

**文本：**双大括号{{message}}（v-once指令可以限制执行一次性插值），数据可以改变但视图不会变化

**原始HTML：**使用v-html指令，需要一个元素作为容器，该容器的内容会被替换为v-html所指的属性

> **注意：**不能用v-html来复合局部模板，因为Vue不是基于字符串的模板引擎，对于用户界面，组件更适合作为可重用和可组合的基本单位。并且，在站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容使用插值。

**特性**：v-bind,通过v-bind绑定HTML attribute

**使用JavaScript表达式**：每个绑定都只能包含**单个表达式**

#### 2.2 指令

指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。

**参数**：如：v-bind:href="url"    v-on:click="doSomething"

**动态参数（2.6.0新增）：**用方括号括起来，如：v-bind:[attributaName]="url"

*约束：动态参数的字符串值为null时，可以显性地移除绑定；动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。*

**修饰符：**以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。

#### 2.3 缩写

**v-bind:**   :

**v-on:**   @

### 3.计算属性和侦听器

#### 3.1计算属性

Vue实例下的computed属性

提供的函数将用作属性的getter函数

**计算属性与方法**

method:方法

computed:计算属性

不同的是**计算属性是基于它们的响应式依赖进行缓存的**。只在相关**响应式依赖**发生改变时它们才会重新求值。这就意味着只要 `message` 还没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。相比之下，每当触发重新渲染时，调用方法将**总会**再次执行函数。

**计算属性与侦听属性**

watch:侦听

侦听属性易被滥用

**计算属性的setter**

#### 3.2 侦听器：

使用watch选项允许我们执行异步操作（访问一个API），限制我们执行某操作的频率

### 4.Class与Style绑定：

在将v-bind用于class和style时，Vue.js做了专门的增强，表达式结果的类型除了字符串还可以是对象或数组

#### 4.1绑定HTML Class

**对象语法**

**数组语法**

**用在组件上**

#### 4.2绑定内联样式

**对象语法**

**数组语法**

**自动添加前缀**

**多重值**

### 5.条件渲染

**5.1 v-if**

`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。

也可以用`v-else-if`, `v-else` 添加一个“else 块”

**5.2 在<template>元素上使用v-if条件渲染分组**

可以把一个 `<template>` 元素当做不可见的包裹元素

**5.3 用key管理可复用的元素**

key属性表示两种元素是完全独立的，不要复用他们

**5.4**  v-show：该元素一直存在，只是切换CSS属性的display

`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

v-if与v-for一起使用：当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级。

### 6.列表渲染

**6.1 用v-for把一个数组对应为一组元素**

`v-for` 还支持一个可选的第二个参数，即当前项的索引。

**6.2 在v-for里使用对象**（会按照Object.keys()的结果遍历）

支持第二个参数键名和第三个参数索引

**6.3 维护状态**

如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。

这个默认的模式是高效的，但是**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**。

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` 属性：key属性是Vue识别节点的一个通用机制

**6.4 数组更新检测**

变异方法：（改变了数组本身）：`push()`,`pop()`,`shift()`,`unshift()`,`splice()`,`sort()`,`reverse()`

替换数组：（不会改变数组本身，因此用新数组替换原始数组，Vue的智能启发式方法使得用含有相同元素的数组替换原来的数组非常高效）：`filter()`,`concat()`,`slice()`

注意事项：由于 JavaScript 的限制，Vue **不能**检测以下数组的变动：

1. 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`

2. 当你修改数组的长度时，例如：`vm.items.length = newLength`

   可以改用以下方法:

   ```JS
   Vue.set(vm.items, indexOfItem, newValue)
   vm.items.splice(indexOfItem, 1, newValue)
   ```

**6.5对象变更检测注意事项**

对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式属性。

有时你可能需要为已有对象赋值多个新属性，比如使用 `Object.assign()` 或 `_.extend()`。

如：

```JS
vm.userProfile = Object.assign({}, vm.userProfile, {
age: 27,
favoriteColor: 'Vue Green'
})
```

`Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

**6.6 显示过滤/排序后的结果**

数组不改变，但要显示过滤/排序后的结果：用方法或者计算属性

**6.7 在v-for里使用值范围**

v-for="n in 10"

### 7.事件处理

**按键修饰符：**

元素获得焦点之后才会触发按键事件，所以要把keyup绑定在document上，或者先触发*获得焦点事件*

**系统修饰符**：

`.ctrl`,`.alt`,`.shift`,`.meta`修饰符仅在按下相应按键时才触发鼠标或键盘事件的监听器

请注意修饰键与常规按键不同，在和 `keyup` 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 `ctrl` 的情况下释放其它按键，才能触发 `keyup.ctrl`。而单单释放 `ctrl` 也不会触发事件。如果你想要这样的行为，请为 `ctrl` 换用 `keyCode`：`keyup.17`。

`.exact`:修饰符允许你控制由精确的系统修饰符组合触发的事件。

<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
`<button @click.ctrl="onClick">A</button>`
<!-- 有且只有 Ctrl 被按下的时候才触发 -->
`<button @click.ctrl.exact="onCtrlClick">A</button>`
<!-- 没有任何系统修饰符被按下的时候才触发 -->
`<button @click.exact="onClick">A</button>`

**鼠标按钮修饰符**

`.left`,`.right`,`.middle`这些修饰符会限制处理函数仅响应特定的鼠标按钮。

### 8.表单输入绑定

`v-model` 在内部为不同的输入元素使用不同的属性并抛出不同的事件：

text 和 textarea 元素使用 `value` 属性和 `input` 事件；

checkbox 和 radio 使用 `checked` 属性和 `change` 事件；

**如果把多个复选框绑定到同一个数组，如果添加value，当选中时会把value值传入数组中**

select 字段将 `value` 作为 prop 并将 `change` 作为事件。

### 9.组件基础









****

## 三.相关构建工具

### 1.webpack打包

WebPack可以看作是一个模块打包机，它用于分析项目结构，找到JS模块以及其他的一些浏览器无法直接运行的拓展语言（scss,typeScript等），将其编译并打包为合适的格式供浏览器使用。

### 2.使用入门

```js
//首先初始化，生成package.json文件，该文件用于记录这个项目的详细信息
npm init
//接下来安装webpack
npm install -g webpack//全局安装
npm install --save-dev webpack //安装到某个项目文件夹
```



