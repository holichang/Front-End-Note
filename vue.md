## 一.相关知识点

#### 1.渐进式框架：

没有强主张，没有多做职责之外的事

#### 2.前端工程化：

[原文](https://www.cnblogs.com/ihardcoder/p/5378290.html)

##### 2.1 前端工程化，面临的问题是如何提高**编码->测试->维护**阶段的生产效率

##### 2.2 要解决前端工程化的问题，可以从两个角度入手：**开发**和**部署**。

从**开发角度**，要解决的问题包括：

（1）提高开发生产效率；

（2）降低维护难度。

这两个问题的解决方案有两点：

（1）制定开发规范，提高团队协作能力；

（2）分治。软件工程中有个很重要的概念叫做**模块化开发**其中心思想就是分治。

从**部署角度**，要解决的问题主要是**资源管理**，包括：

（1）代码审查；

（2）压缩打包；

（3）增量更新；

（4）单元测试；

**模块化开发：**

##### 2.3 构建&编译

2016年节点下，一个典型的web前后端协作模式如下图：

![img](https://images2015.cnblogs.com/blog/595796/201604/595796-20160411142716207-1803317219.png)

**大前端模式下：**

![img](https://images2015.cnblogs.com/blog/595796/201604/595796-20160411142733598-1823214206.png)

大前端体系下，前端开发人员掌握着Node.js搭建的web server层。与上文提到的常规前端开发体系下相比，省略了mock server的角色，但是构建在大前端体系下的作用并没有发生改变。也就是说，不论是大前端还是“小”前端，构建阶段在两种模式下的作用完全一致，**构建的作用就是对静态资源以及模板进行处理**，换句话说：**构建的核心是资源管理**。

**什么是资源管理？**

前端的资源可以分为**静态资源**和**模板**。模板对静态资源是引用关系，两者相辅相成，构建过程中需要对两种资源使用不同的构建策略。

静态资源包括js、css、图片等文件，目前随着一些新规范和css预编译器的普及，通常开发阶段的静态资源是：

1. es6/7规范的文件；
2. less/sass等文件（具体看团队技术选型）；
3. [可选]独立的小图标，在构建阶段使用工具处理成spirit图片。

构建可以分为**工具层面**和**平台层面**的功能：

- 工具层面

1. 预编译，包括es6/7语法转译（比如babel）、css预编译器处理（如将less/sass编译成css）、spirit图片生成；
2. 依赖打包。分析文件依赖关系，将同步依赖的的文件打包在一起，减少http请求数量；
3. 资源嵌入。比如小于10KB的图片编译为base64格式嵌入文档，减少一次http请求；
4. 文件压缩。减小文件体积；
5. hash指纹。通过给文件名加入hash指纹，以应对浏览器缓存引起的静态资源更新问题；
6. 代码审查。避免上线文件的低级错误；
7. 模板构建。

- 平台层面

1. 文件监听。配合动态构建、浏览器自动刷新等功能，提高开发效率；
2. mock server。并非所有前端团队都是大前端（事实上很少团队是大前端），即使在大前端体系下，mock server的存在也是很有必要的；

##### 2.4 总结;

一个完整的前端工程体系应该包括：

（1）统一的开发规范；

（2）组件化开发；

（3）构建流程。

#### 3.脚手架

简易前端工作流如下：

![1569339963707](C:\Users\凌多\AppData\Roaming\Typora\typora-user-images\1569339963707.png)

脚手架：作用是创建项目的初始文件,**让项目从"搭建-开发-部署"更加快速以及规范**，前端脚手架的实质包含两项，命令式的构建项目（解析命令，拷贝项目到本地），提供项目的配置（构建，编译，代码规范检查）,同时应具备高度可扩展性

#### 4.构建

webpack，babel，Gulp,Grunt





#### 5.less 和 sass

css预编译器

#### 6.MVVM与MVC

**MVVM**:Model-View-ViewModle：模型-视图-**视图模型（核心：双向桥梁）**

【模型】转为【视图】：数据绑定

【视图】转为【模型】：DOM事件监听

在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。

**MVC：**Model-View- Controller：MVC是单向通信。也就是View跟Model，必须通过Controller（页面业务逻辑）来承上启下

ViewModel存在目的在于抽离Controller中展示的业务逻辑

主流框架实现双向绑定（响应式）：

**（1）脏值检查 **（angular.js）
**（2）观察者-订阅者（数据劫持）**（Vue.js）VueObserver数据监听器

Vue双向绑定原理：

![Vue双向绑定](E:\Front-End-Note\image\Vue双向绑定.jpg)

从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行解析，初始化视图，并订阅Watcher 来更新视图， 此时Watcher 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。因为VUE使用Object.defineProperty方法来做数据绑定，而这个方法又无法通过兼容性处理，所以Vue 不支持 IE8 以及更低版本浏览器。另外，查看vue原代码，发现在vue初始化实例时， 有一个proxy代理方法，它的作用就是遍历data中的属性，把它代理到vm的实例上，这也就是我们可以这样调用属性：vm.aaa等于vm.data.aaa。

**proxy代理：**

****

## 二.Vue知识点：

### 1.实例

每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。

<img src="E:\Front-End-Note\image\vue生命周期.png" alt="vue生命周期" style="zoom:50%;" />

### 2.模板语法

#### 2.1 插值

**文本：**双大括号{{message}}（v-once指令可以限制执行一次性插值）

**原始HTML：**使用v-html指令

**特性**：v-bind

**使用JavaScript表达式**：每个绑定都只能包含**单个表达式**

#### 2.2 指令

指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。

**参数**：如：v-bind:href="url"    v-on:click="doSomething"

**动态参数：**用方括号括起来，如：v-bind:[attributaName]="url"

*约束：动态参数的字符串值为null时，可以显性地移除绑定；动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。*

**修饰符：**以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。

#### 2.3 缩写

**v-bind:**   :

**v-on:**   @

### 3.计算属性和侦听器

#### 3.1计算属性

Vue实例下的computed属性

提供的函数将用作属性的getter函数

**计算属性与方法**

method:方法

computed:计算属性

不同的是**计算属性是基于它们的响应式依赖进行缓存的**。只在相关**响应式依赖**发生改变时它们才会重新求值。这就意味着只要 `message` 还没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。相比之下，每当触发重新渲染时，调用方法将**总会**再次执行函数。

**计算属性与侦听属性**

watch:侦听

侦听属性易被滥用

**计算属性的setter**

#### 3.2 侦听器

### 4.Class与Style绑定：

在将v-bind用于class和style时，表达式结果的类型除了字符串还可以是对象或数组

#### 4.1绑定HTML Class

**对象语法**

**数组语法**

**用在组件上**

#### 4.2绑定内联样式

**对象语法**

**数组语法**

**自动添加前缀**

**多重值**

### 5.条件渲染

**5.1 v-if**

`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。

也可以用`v-else-if`, `v-else` 添加一个“else 块”

**5.2 在<template>元素上使用v-if条件渲染分组**

可以把一个 `<template>` 元素当做不可见的包裹元素

**5.3 用key管理可复用的元素**

key属性表示两种元素是完全独立的，不要复用他们

**5.4**  v-show：该元素一直存在，只是切换CSS属性的display

`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

v-if与v-for一起使用：当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级。

### 6.列表渲染

**6.1 用v-for把一个数组对应为一组元素**

`v-for` 还支持一个可选的第二个参数，即当前项的索引。

**6.2 在v-for里使用对象**（会按照Object.keys()的结果遍历）

支持第二个参数键名和第三个参数索引

**6.3 维护状态**

如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。

这个默认的模式是高效的，但是**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**。

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` 属性：key属性是Vue识别节点的一个通用机制

**6.4 数组更新检测**

变异方法：（改变了数组本身）：`push()`,`pop()`,`shift()`,`unshift()`,`splice()`,`sort()`,`reverse()`

替换数组：（不会改变数组本身，因此用新数组替换原始数组，Vue的智能启发式方法使得用含有相同元素的数组替换原来的数组非常高效）：`filter()`,`concat()`,`slice()`

注意事项：由于 JavaScript 的限制，Vue **不能**检测以下数组的变动：

1. 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`

2. 当你修改数组的长度时，例如：`vm.items.length = newLength`

   可以改用以下方法:

   ```JS
   Vue.set(vm.items, indexOfItem, newValue)
   vm.items.splice(indexOfItem, 1, newValue)
   ```

**6.5对象变更检测注意事项**

对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式属性。

有时你可能需要为已有对象赋值多个新属性，比如使用 `Object.assign()` 或 `_.extend()`。

如：

```JS
vm.userProfile = Object.assign({}, vm.userProfile, {
age: 27,
favoriteColor: 'Vue Green'
})
```

`Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

**6.6 显示过滤/排序后的结果**

数组不改变，但要显示过滤/排序后的结果：用方法或者计算属性

**6.7 在v-for里使用值范围**

v-for="n in 10"

### 7.事件处理

**按键修饰符：**

元素获得焦点之后才会触发按键事件，所以要把keyup绑定在document上，或者先触发*获得焦点事件*

**系统修饰符**：

`.ctrl`,`.alt`,`.shift`,`.meta`修饰符仅在按下相应按键时才触发鼠标或键盘事件的监听器

请注意修饰键与常规按键不同，在和 `keyup` 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 `ctrl` 的情况下释放其它按键，才能触发 `keyup.ctrl`。而单单释放 `ctrl` 也不会触发事件。如果你想要这样的行为，请为 `ctrl` 换用 `keyCode`：`keyup.17`。

`.exact`:修饰符允许你控制由精确的系统修饰符组合触发的事件。

<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
`<button @click.ctrl="onClick">A</button>`
<!-- 有且只有 Ctrl 被按下的时候才触发 -->
`<button @click.ctrl.exact="onCtrlClick">A</button>`
<!-- 没有任何系统修饰符被按下的时候才触发 -->
`<button @click.exact="onClick">A</button>`

**鼠标按钮修饰符**

`.left`,`.right`,`.middle`这些修饰符会限制处理函数仅响应特定的鼠标按钮。

### 8.表单输入绑定

`v-model` 在内部为不同的输入元素使用不同的属性并抛出不同的事件：

text 和 textarea 元素使用 `value` 属性和 `input` 事件；

checkbox 和 radio 使用 `checked` 属性和 `change` 事件；

**如果把多个复选框绑定到同一个数组，如果添加value，当选中时会把value值传入数组中**

select 字段将 `value` 作为 prop 并将 `change` 作为事件。

### 9.组件基础









****

## 三.慕课课程

父组件向子组件传值：v-bind

子组件向父组件传值：.$emit(event,argu)