[TOC]



#### 1.端口

**什么是端口：**

本地操作系统会给那些有需求的进程分配协议端口 （protocal port，即我们常说的端口），每个协议端口由一个正整数标识，如：80，139，445，等等。当目的主机接收到数据报后，将根据报文首部的目的端口 号，把数据发送到相应端口，而与此端口相对应的那个进程将会领取数据并等待下一组数据的到来。

**端口分类：**

  在Internet上，按照协议类型分类，端口被分为TCP端口和UDP端口两类，虽然他们都用正整数标识，但这并不会引起歧义，比如TCP的80端口和UDP的80端口，因为数据报在标明端口的同时，还将标明端口的类型。 

（TCP：传输控制协议：是基于连接的协议，也就是说在正式收发数据前，必须和对方建立可靠的连接，进行“三次握手”

   UDP：用户数据报协议，是面向非连接的协议i，不与对方建立连接，而是直接就把数据包发送过去，适用于一次只传送少量数据，对可靠性要求不高的应用环境，如“ping”命令和QQ）

　　从端口的分配来看，端口被分为固定端口和动态端口两大类（一些教程还将极少被用到的高端口划分为第三类：私有端口）：
　　固定端口（0－1023）：
　 　使用集中式管理机制，即服从一个管理机构对端口的指派，这个机构负责发布这些指派。由于这些端口紧绑于一些服务，所以我们会经常扫描这些端口来判断对方 是否开启了这些服务，如TCP的21（ftp），80（http），139（netbios），UDP的7（echo），69（tftp）等等一些大家熟 知的端口；
　　动态端口（1024－49151）：
　　这些端口并不被固定的捆绑于某一服务，操作系统将这些端口动态的分配给各个进程， 同一进程两次分配有可能分配到不同的端口。不过一些应用程序并不愿意使用操作系统分配的动态端口，他们有其自己的‘商标性’端口，如oicq客户端的 4000端口，木马冰河的7626端口等都是固定而出名的。

#### 2.127.0.0.1与0.0.0.0

**IP地址表示：**

IP地址由两个部分组成，net-id和host-id，即网络号和主机号。 
net-id:表示ip地址所在的网络号。 
host-id：表示ip地址所在网络中的某个主机号码。 
即：

```xml
  IP-address ::= { <Network-number>, <Host-number> }
```

**IP地址分类**

IP地址一共分为5类，即A～E，它们分类的依据是其net-id所占的字节长度以及网络号前几位。 

A类地址:网络号占1个字节。网络号的第一位固定为0。 

B类地址：网络号占2个字节。网络号的前两位固定为10。 

C类地址：网络号占3个字节。网络号的前三位固定位110。 

D类地址：前四位是1110，用于多播(multicast)，即一对多通信。 

E类地址：前四位是1111，保留为以后使用。 

其中，ABC三类地址为单播地址（unicast),用于一对一通信，是最常用的。

![1571194707(1)](D:\Front-End-Note\image\1571194707(1).png)

**特殊IP地址**

特殊IP地址就是用来做一些特殊的事情。RFC1700中定义了以下特殊IP地址。 

{0,0}:网络号和主机号都全部为0，表示“本网络上的本主机”，只能用作源地址。 

{0，host-id}:本网络上的某台主机。只能用作源地址。 

{-1,-1}：表示网络号和主机号的所有位上都是1（二进制），用于本网络上的广播，只能用作目的地址，发到该地址的数据包不能转发到源地址所在网络之外。 

{net-id,-1}:直接广播到指定的网络上。只能用作目的地址。 

{net-id,subnet-id,-1}:直接广播到指定网络的指定子网络上。只用作目的地址。 

{net-id,-1,-1}:直接广播到指定网络的所有子网络上。只能用作目的地址。 

{127，}:即网络号为127的任意ip地址。都是内部主机回环地址(loopback),永远都不能出现在主机外部的网络中。

**127.0.0.1与0.0.0.0的共同点：**

1. 都属于特殊地址。 
2. 都属于A类地址。 
3. 都是IPV4地址。

**127.0.0.1：**本地loopback(回环)地址，代表本地主机（在window和linux上等价于localhost）

**0.0.0.0:**IPV4中，0.0.0.0地址被用于表示一个无效的，未知的或者不可用的目标。 

* 在服务器中，0.0.0.0指的是本机上的所有IPV4地址，如果一个主机有两个IP地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0,那么通过两个ip地址都能够访问该服务。 

* 在路由中，0.0.0.0表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。
* 用途：
  - 当一台主机还没有被分配一个IP地址的时候，用于表示主机本身。（DHCP分配IP地址的时候）
  - 用作默认路由，表示”任意IPV4主机”。
  - 用来表示目标机器不可用。
  - 用作服务端，表示本机上的任意IPV4地址。

0.0.0.0是最特殊的一个ip地址，代表的是本机所有ip地址，不管你有多少个网口，多少个ip，如果监听本机的0.0.0.0上的端口，就等于监听机器上的所有ip端口。换句话说，就是只要数据报目的地址是你机器上的一个ip地址，那么就能被接受。

IPv4的回路地址为: 127.0.0.1

IPv6的回路地址为 : 000:0000:0000:0000:0000:0000:0000:0001 可以简写为 ::1。 　

（[IPV6格式](https://www.cnblogs.com/lsgxeva/p/9209266.html) ）

#### 3.Http与Https

**Https:**

Https设计目标：

(1)数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。

(2)数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。

(3)身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。

Https原理：

① 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；

② 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；

③ 客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器；

④ 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 MAC密钥（参考 DH密钥交换算法） ；

⑤ 客户端将所有握手消息的 MAC 值发送给服务器；

⑥ 服务器将所有握手消息的 MAC 值发送给客户端。

##### 3.1 区别

（1）https协议需要到CA  （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)

（2）http是超文本传输协议，信息是**明文传输**，https则是具有安全性的**ssl加密传输**协议。

（3）http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

（4）http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

**3.2 Https相对于Http的改进：**

（1）双向身份认证：客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证

3次握手：

第一次：客户端发起 SSL 握手消息给服务端要求连接。

第二次：服务端将证书发送给客户端。

客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。

第三次：服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。

（2）数据传输的机密性：客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法

（3）防止重放攻击

**3.2 加密算法和SSL协议**

SSL协议：Https的安全基础

SSL协议位于[TCP/IP协议](https://baike.baidu.com/item/TCP/IP协议)与各种应用层协议之间，为[数据通讯](https://baike.baidu.com/item/数据通讯)提供安全支持。SSL协议可分为两层：SSL记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol），它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

**SSL提供服务**
(1)认证用户和服务器，确保数据发送到正确的客户机和服务器；

(2)加密数据以防止数据中途被窃取；

(3)维护数据的完整性，确保数据在传输过程中不被改变。

**SSL工作流程**
**服务器认证阶段：**

(1)客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；

(2)服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；

(3)客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；

(4)服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。

**用户认证阶段：**在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。

**SSL协议提供的安全通道有以下三个特性：**

机密性：SSL协议使用密钥加密通信数据。

可靠性：服务器和客户都会被认证，客户的认证是可选的。

完整性：SSL协议会对传送的数据进行完整性检查。

**服务器证书**(server certificates)是SSL数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成Web服务器的SSL安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户 提供验证您Web站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。

##### 3.3Https的优缺点

**优点：**

（1）使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

（2）Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中被窃取、修改，确保数据的完整性。

（3）Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
**缺点：**

（1）Https协议握手阶段比较费时，会使页面的加载时间延长近。

（2）Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。

（3）Https协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。

（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

（5）成本增加。部署 Https后，因为 Https协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。

（6）Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。
**3.4 Https的连接过程**

![https连接过程](D:\Front-End-Note\image\https连接过程.jpg)

过程讲解：

图片中的过程是按8个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。

①客户端的浏览器向服务器发送请求，并传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。

②服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。

③客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。

④用户端随机产生一个用于通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。

⑤如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。

⑥如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。

⑦服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。

⑧客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。

⑨服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。

⑩SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。

#### 4.WebSocket(基于HTML5规范)

http和https的机制缺陷：

（1）不适用于实时要求高、海量并发的应用

（2）服务器不能主动向客户端推送数据，只能使用轮询，在特定的时间间隔，浏览器自动发出请求将服务器的消息主动拉回来。

（3）http请求header

#### 5.session:记录一系列状态

session:记录在服务器端

cookie:记录在浏览器端

解释：当访问服务器否个网页的时候，会在服务器端的内存里开辟一块内存，这块内存就叫做session，而这个内存是跟浏览器关联在一起的。这个浏览器指的是浏览器窗口，或者是浏览器的子窗口，意思就是，只允许当前这个session对应的浏览器访问，就算是在同一个机器上新启的浏览器也是无法访问的。而另外一个浏览器也需要记录session的话，就会再启一个属于自己的session

原理：http的非连接性

浏览器与服务器session的一一对应：通过赋予相同的sessionID

**session两种实现方式：**

（1）放在cookie（临时cookie会在浏览器关闭时消失）里面：当浏览器允许使用cookie时可以通过这种方式

（2）编程使用URL重写：通过`response.encodeURL()`方法，转码后加上sessionID：当cookie被浏览器禁用时使用

#### 6.关于浏览器中使用JS跨域获取数据

**1.CORS**

CORS（Cross-Origin Resource Sharing,跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。

完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。

**只要 协议 、 域名 、 端口 有任何一个 不同, 都被当作是 不同 的域。**

**2.document.domain**

将页面的 `document.domain` 设置为相同的值，页面间可以互相访问对方的JavaScript对象。

注意：

不能将值设置为URL中不包含的域；

松散的域名不能再设置为紧绷的域名。

**3.图像Ping**

```javascript
var img=new Image();

img.onload=img.onerror=function(){

... ...

}

img.src="url?name=value";
```

请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。

图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。

缺点：

只能发送GET请求；

无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。

**4.Jsonp**

```javascript
var script=document.createElement("script");

script.src="url?callback=handleResponse";

document.body.insertBefore(script,document.body.firstChild);
```

JSONP由两部分组成：回调函数和数据

回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。

数据是传入回调函数中的JSON数据。

优点：

能够直接访问响应文本，可用于浏览器与服务器间的双向通信。

缺点：

JSONP从其他域中加载代码执行，其他域可能不安全；

难以确定JSONP请求是否失败。

**5.Comet**

Comet可实现服务器向浏览器推送数据。

Comet是实现方式：长轮询和流

短轮询即浏览器定时向服务器发送请求，看有没有数据更新。

长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。

流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。

**6.WebSocket**

WebSocket可在一个单独的持久连接上提供全双工、双向通信。

WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。

```javascript
var webSocket=new WebSocket("ws://");

webSocket.send(message);

webSocket.onmessage=function(event){

var data=event.data;

... ....

}
```

注意：

必须给WebSocket构造函数传入绝对URL；

WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；

WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。

优点：

在客户端和服务器之间发送非常少的数据，减少字节开销。

#### 7.文档类型和浏览器模式

**文档类型**

  DTD（文档类型定义）是一组机器可读的规则，他们定义 XML 或 HTML 的特定版本中允许有什么，不允许有什么。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。浏览器通过分析页面的 DOCTYPE 声明来了解要使用哪个 DTD ，由此知道要使用 HTML 的哪个版本。

 DOCTYPE 当前有两种风格，严格（ strict ）和过渡（ transitional ）。过渡 DOCTYPE 的目的是帮助开发人员从老版本迁移到新版本。

如果发送具有正确的 MIME 类型的 XHTML 文档，理解 XML 的浏览器将不显示无效的页面。

**浏览器模式**

  浏览器有两种呈现模式：标准模式和混杂模式（quirks mode）。在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。

**DOCTYPE 切换**

对于 HTML 4.01 文档，

- 包含严格 DTD 的 DOCTYPE 常常导致页面以标准模式呈现。
- 包含过度 DTD 和 URI 的 DOCTYPE 也导致页面以标准模式呈现。
- 但是有过度 DTD 而没有 URI 会导致页面以混杂模式呈现。
- DOCTYPE 不存在或形式不正确会导致 HTML 和 XHTML 文档以混杂模式呈现。

#### 8.五大主流浏览器及四大内核

浏览器最重要的部分是浏览器的内核。浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。

浏览器内核又可以分为两部分：渲染引擎和JS引擎（随着JS引擎越来越独立，内核就倾向于只指渲染引擎）**常见的浏览器内核可以分为四种：Trident,Gecko,Blink,Webkit**

（1）IE浏览器内核：Trident内核，也是俗称的IE内核；
（2）Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；
（3）Firefox浏览器内核：Gecko内核，俗称Firefox内核；
（4）Safari浏览器内核：Webkit内核；
（5）Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核；
（6）360浏览器、猎豹浏览器内核：IE+Chrome双内核；
（7）搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；
（8）百度浏览器、世界之窗内核：IE内核；
（9）2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；



****

## 面经

#### 1. 说一下http和https

**1.1 基本概念**

**1.2 二者区别**

**1.3  https协议的工作原理**

**1.4 https协议的优点**

**1.5 https协议的缺点**

#### 2.TCP

**2.1 tcp的三次握手**

**2.2. TCP和UDP的区别**

#### 3.WebSocket的实现和应用

#### 4.HTTP请求的方式，HEAD方式

****

****

### 图解HTTP

#### 1. 了解web及网络基础

**1.1 与http关系密切的协议：ip、tcp、dns**

IP协议：位于网络层：作用是把各种数据包传送给对方，两个重要条件是IP地址和MAC（Media Access Control Address）地址，IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址，IP地址可以和MAC地址进行配对，IP地址可变换，但MAC地址基本不会更改（ARP协议：Address Resolution Protocol:用于解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址）

**1.2 确保可靠性的TCP协议：位于传输层，提供可靠的字节流服务**

（1）字节流服务：即将大块数据分割成以报文段为单位的数据包进行管理；

（2）可靠的传输服务是指：能够把数据准确可靠的传给对方，依靠三次握手（发送端首先发送一个带SYN（同步序列编号）标志的数据包给对方，接收端收到后回传一个带有SYN+ACK（确认字符）标志的数据包以示传达确认信息，最后发送端再回传一个带ACK标志的数据包，代表”握手“结束）

**1.3 负责域名解析的DNS服务：位于应用层，提供域名到IP地址之间的解析服务**

#### 2. 简单的HTTP协议

**2.1 通过请求和响应的交换达成通信**

请求报文：由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成

响应报文：由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成

**2.2 HTTP是不保存状态的协议，即无状态协议**

即HTTP协议自身不具备保存之前发送过的请求或响应的功能，是为了更快处理大量事务，确保协议的可伸缩性 。（**因此引入cookie**）

**2.3 告知服务器意图的HTTP方法**(1.1)

（1）GET：获取资源

（2）POST：传输实体主体

（3）PUT：传输文件：就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。但是鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。

（4）HEAD：获得报文首部：用于确认URI的有效性及资源更新的日期时间等

（5）DELETE：删除文件：按照请求URI删除指定的资源（不带验证机制，一般不使用）

（6）OPTIONS：询问支持的方法：用来查询针对请求URI指定的资源支持的方法

（7）TRACE：追踪路径：让Web服务器端将之前的请求通信环回给客户端，客户端通过TRACE方法可以查询发送出去的请求是怎样被加工/篡改的，但是该方法 不常用，易引发XST（Cross-Site Tracing,跨站追踪）攻击

（8）CONNECT：要求用隧道协议连接代理：要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer,安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输

**2.4 持久连接节省通信量**

![image-20200221232507221](C:\Users\Lihang\AppData\Roaming\Typora\typora-user-images\image-20200221232507221.png)

**持久连接（keep-alive）：**好处在于**减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器的负载，使Web页面显示速度相应提高**，在HTTP 1.1中默认都是持久连接

**管线化：**不用等待响应即可发送下一个请求

![image-20200221232944521](C:\Users\Lihang\AppData\Roaming\Typora\typora-user-images\image-20200221232944521.png)

#### 3. HTTP报文内的HTTP信息

**3.1 请求报文和响应报文的结构：**

请求报文：报文首部（请求行+请求首部字段+通用首部字段+实体首部字段+其他）+空行+报文主体

响应报文：报文首部（状态行+响应首部字段+通用首部字段+实体首部字段+其他）+空行+报文主体

**3.2 编码提升传输速率**

**报文主体**和**实体主体**：HTTP报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

**压缩传输的内容编码**

**分块传输编码：**在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面

**3.3 发送多种数据的多部分对象集合**

**3.4 获取部分内容的范围请求**

**3.5 内容协商返回最合适的内容：**内容协商机制：指客户端和服务器端就响应得资源内容进行交涉，然后提供给客户端最为合适的资源（内容协商技术有以下3种类型：服务器驱动协商；客户端驱动协商；透明协商）

#### 4. 返回结果的http状态码（常用14种）

**状态码类别：**

1XX：Information（信息性状态码）：接收的请求正在处理

**2XX：Success（成功状态码）：请求正常处理完毕**

200 OK：表示从客户端发来的请求在服务器端被正常处理了

204 No Content：表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分

206 Partial Content：表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求

**3XX：Redirection（重定向状态码）：需要进行附加操作以完成请求**

301 Moved Permanently：永久性重定向，该状态码表示请求的资源已被分配了新的URI，**以后**应使用资源现在所指的URI

302 Found：临时性重定向，该状态码表示请求的资源已被分配了新的URI，希望用户**本次**能使用新的URI访问

303 See Other：与302状态码有着相同功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302有区别

304 Not Modified（与重定向无关）：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况，不包含任何响应的主体部分(**如协商缓存机制中的：If-Modified-Since和If-None-Match**)

307 Temporary Redirect（临时重定向）：与302有着相同含义，遵守浏览器标准，不会从POST变为GET

**4XX：Client Error（客户端错误状态码）：服务器无法处理请求**

400 Bad Request：表示请求报文中存在语法错误

401 Unauthorized：表示发送的请求需要有通过HTTP认证的认证信息，另外若之前已进行过一次HTTP请求，则表示用户认证失败

403 Forbidden：表明对请求资源的访问被服务器拒绝了

404 Not Found：表明服务器上无法找到请求的资源（也可以在服务器端拒绝请求且不想说明理由时使用）

412 Precondition Failed :先决条件失败

**5XX：Server Error（服务器错误状态码）：服务器处理请求出错**

500 Internal Server Error：该状态码表示服务器端在执行请求时发生了错误

503 Service Unavailable：表明服务器端暂时处于超负载或正在进行停机维护，现在无法处理请求

#### 5. 与http协作的web服务器

一台Web服务器可搭建多个独立域名的Web网站，也可作为通信路径上的中转服务器提升传输效率

**5.1 通信数据转发程序：代理、网关、隧道：**

**代理：**是一种有转发功能的应用程序（每次通过代理服务器转发请求或响应时，会追加写入Via首部信息）

使用代理服务器的理由：利用缓存技术减少网络带宽流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的（**透明代理和非透明代理（如缓存代理）**）

**网关：**网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。网关的工作机制与代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议服务（**利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保传输安全**）

**隧道：**可按要求建立起一条与其他服务器通信的通信线路，届时使用SSL等加密手段进行通信。（**目的是确保客户端和服务器端能进行安全的通信**）通过隧道的传输，可以和远距离的服务器安全通信，隧道本身是透明的，客户端不用在意隧道的存在

**5.2 缓存资源** 

（1）缓存在缓存服务器上

（2）缓存在客户端浏览器中

> http缓存机制：
>
> HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，可将其分为两大类（强制缓存，对比缓存），可同时存在。
>
> 区别:强制缓存如果生效，不需要和服务器进行交互，而对比缓存无论是否生效都要与服务器发生交互，且强制缓存优先级高于对比缓存。
>
> > 强制缓存：
> >
> > 问题：怎么判断缓存数据是否失效？
> >
> > 在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则包含在响应首部中。在强制缓存中，响应header会有两个字段来标明失效规则**Expires **（http1.0）/**Cache-Control**(http1.1)
> >
> > > Cache-Control常见取值：
> > >
> > > private:客户端可以缓存
> > >
> > > public:客户端和代理服务器都可以缓存
> > >
> > > max-age=xxx: xxx秒后失效
> > >
> > > no-cache:需要使用对比缓存来验证缓存数据
> > >
> > > no-store：所有内容都不会缓存，强制缓存，对比缓存都不会触发
>
> >对比缓存：浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回**304**状态码，通知客户端比较成功，可以使用缓存数据。
> >
> >对比缓存的缓存标识：
> >
> >>Last-Modified:第一次请求时，服务器端响应首部包含该字段，表示该资源上一次被修改的时间
> >>
> >>If-Modified-Since：再次请求时，客户端的请求报文中包含该字段，表示该请求资源上次请求时返回的资源最后修改时间，服务器端收到后与最后一次资源被修改的时间进行对比，若大于该时间，则返回200状态码并响应整个资源实体，否则返回304状态码，不含实体主体，告知客户端可以继续使用缓存数据，
> >>
> >>Etag / If-None-Match（优先级高于Last Modified/If-Modified-Since）
> >>
> >>>Etag :第一次请求资源时，服务器返回当前资源的唯一标识
> >>>
> >>>If-None-Match：再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识。服务器收到请求后则将If-None-Match 与被请求资源的唯一标识进行比对，
> >>>不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；
> >>>相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的Etag。

#### 6. http首部

**6.1 http报文首部**

**6.2 http首部字段**

End-to-end Header：端到端首部：分在此类别中的首部会转发给请求/响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。

Hop-by-hop Header：逐跳首部：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。（HTTP/1.1中的8个逐跳首部字段：Connection，Keep-Alive,Proxy-Authenticate,Proxy-Authorization,Trailer,TE,Transfer-Encoding,Upgrade）

**6.3 HTTP/1.1 通用首部字段**

| 字段              | 解释                                                         | 补充    |
| :---------------- | ------------------------------------------------------------ | ------- |
| Cache-Control     | 操作缓存的工作机制                                           |         |
| Connection        | 控制不再转发给代理的首部字段；管理持久连接                   |         |
| Date              | 表明创建HTTP报文的日期和时间                                 |         |
| Trailer           | 事先说明在报文主体后记录了哪些首部字段                       |         |
| Transfer-Encoding | 规定了传输报文主体时采用的编码方式                           | chunked |
| Upgrade           | 用于检测HTTP协议及其他协议是否可使用更高版本进行通信         |         |
| Via               | 为了追踪客户端与服务器之间的请求和响应报文的传输路径         |         |
| Warning           | \[警告码\] \[警告的主机：端口号] \["警告内容"] \([日期时间]) |         |

**6.4 请求首部字段**

| 字段                | 解释                                                         | 补充                                |
| ------------------- | ------------------------------------------------------------ | ----------------------------------- |
| Accept              | 告知服务器用户代理能够处理的媒体类型及相对优先级             | q=来表示权重                        |
| Accept-Charset      | 通知服务器用户代理支持的字符集及相对优先级                   | 服务器驱动协商/q=                   |
| Accept-Encoding     | 告知服务器用户代理支持的内容编码及相对优先级                 | q=                                  |
| Accept-Language     | 告知服务器用户代理能够处理的自然语言集及相对优先级           | q=                                  |
| Authorization       | 在接收到401状态码响应后，告知用户代理的认证信息              | 响应：WWW-Authenticate              |
| Expect              | 告知服务器客户端期望出现的某种特定行为                       | 发生错误：417（Expectation Failed） |
| From                | 用于告知服务器使用用户代理的用户的电子邮件地址               | 也可能记录在User-Agent字段内        |
| Host                | 告知服务器请求资源所处的互联网主机名和端口号                 | 必须存在                            |
| If-Match            | 服务器会对比If-Match的字段值和资源的ETag值，仅当两者一致的时候才会执行请求 | 否则返回412（Precondition Failed）  |
| If-Modified-Since   | 只有资源在指定时间后发生更新的情况下才进行处理，用于确认资源的有效性 | 否则返回304                         |
| If-None-Match       | 与If-Match相反，用于确认资源有效性                           |                                     |
| If-Range            | 告知服务器若指定的If-Range字段值（Etag值或时间）和请求资源的ETag值或时间相一致时，则作为范围请求处理。否则返回全体资源 |                                     |
| If-Unmodified-Since | 与If-Modified-Since相反                                      | 否则返回412                         |
| Max-Forwards        | 指定可经过的服务器最大数目                                   | 逐个减1，=0时响应                   |
| Proxy-Authorization | 接收到从代理服务器发来的认证质询时，客户端会发送包含该字段的请求 |                                     |
| Range               | 告知服务器资源的请求范围                                     | 206/200                             |
| Referer             | 告知服务器请求的原始资源的URI，即来源信息                    |                                     |
| TE                  | 1.告知服务器客户端能够处理响应的传输编码方式及相对优先级 2.指定伴随trailer字段的分块传输编码方式 |                                     |
| User-Agent          | 将创建请求的浏览器和用户代理名称等信息传达给服务器           |                                     |

**6.5 响应首部字段**

| 字段               | 解释                                                         | 补充                   |
| ------------------ | ------------------------------------------------------------ | ---------------------- |
| Accept-Ranges      | 告知客户端服务器是否能处理范围请求                           | 值为bytes/none         |
| Age                | 1.告知客户端服务器在多久前创建了响应；2.若创建该响应的是缓存服务器，Age值是指缓存后的响应再次发起认证到认证完成的时间值 | 代理创建响应必须加Age  |
| ETag               | 分为强ETag（无论实体发生多么细微的变化都会改变其值）和弱ETag（在字段值前加W：只有资源发生了根本改变，产生差异时才会改变ETag） |                        |
| Location           | 配合3XX重定向状态码，可以将响应接收方引导至某个与请求URI位置不同的资源 |                        |
| Proxy-Authenticate | 把代理服务器所要求的认证信息发送给客户端                     | 客户端与代理服务器之间 |
| Retry-After        | 主要配合状态码503 Service Unavailable或3XX Redirect响应一起使用 |                        |
| Server             | 告知客户端当前服务器上安装的HTTP服务器应用程序的信息         |                        |
| Vary               | 对缓存进行控制，源服务器响应报文中Vary字段指定的首部字段相同时，才能返回缓存，否则要从源服务器重新获取资源 |                        |
| WWW-Authenticate   | 用于HTTP访问认证                                             | 401中一定包含          |

**6.6 实体首部字段**：用于 补充内容的更新时间等于实体相关的信息

| 字段             | 解释                                                         | 补充                             |
| ---------------- | ------------------------------------------------------------ | -------------------------------- |
| Allow            | 通知客户端能够支持制定资源的所有HTTP方法                     | 405（Method Not Allowed）        |
| Content-Encoding | 告知客户端服务器对实体主体选用的编码方式                     | gzip;conpress;deflate;identity   |
| Content-Language | 告知客户端实体主体使用的自然语言                             |                                  |
| Content-length   | 表明实体主体部分的大小                                       |                                  |
| Content-Location | 给出与报文主体部分相对应的URI                                | 与Location相比无需再进行内容协商 |
| Content-MD5      | 该字段是一串由MD5算法生成的值，目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达 | 无法查证内容的偶发性改变         |
| Content-Range    | 实体主体的范围                                               |                                  |
| Content-Type     | 实体主体内对象的媒体类型                                     |                                  |
| Expires          | 缓存资源的有效期                                             | max-age优先级更高                |
| Last-Modified    | 资源最后被修改的时间                                         |                                  |

**6.7 为cookie服务的首部字段**

cookie工作机制：用户识别及状态管理

| 首部字段名 | 说明                           | 首部类型     |
| ---------- | ------------------------------ | ------------ |
| Set-Cookie | 开始状态管理所使用的Cookie信息 | 响应首部字段 |
| Cookie     | 服务器接收到的Cookie信息       | 请求首部字段 |

**6.8 其他首部字段**

| 字段             | 说明                                                         | 首部类型     | 字段值                                                 |
| ---------------- | ------------------------------------------------------------ | ------------ | ------------------------------------------------------ |
| X-Frame-Options  | 控制网站内容在其他Web网站的Frame标签内的显示问题：防止点击劫持（clickjacking）攻击 | 响应首部字段 | DENY/SAMEORIGIN（仅同源域名下的页面匹配时许可）        |
| X-XSS-Protection | 针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器XSS防护机制的开关 | 响应首部字段 | 0：将XSS过滤设置成无效状态；1：将XSS过滤设置成有效状态 |
| DNT              | Do Not Track：拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法 | 请求首部字段 | 0：同意被追踪；1：拒绝被追踪                           |
| P3P              | The Platform Privacy Preferences：在线隐私偏好平台，用于保护用户隐私 | 响应首部     |                                                        |

同源：同域名，同端口，同协议

跨域：跨域名，跨端口，跨协议

#### 7. 确保web安全的https

**7.1 http的缺点**

（1）通信使用明文（不加密），可能遭窃听；

**通信的加密：通过和SSL（Secure Socket Layer,安全套接层）或TLS（Transport Layer Security,安全层传输协议）的组合使用，加密HTTP的通信内容**：https

**内容的加密：对报文主体进行加密，但该方法仍有内容被篡改的风险**

（2）不验证通信方身份，可能遭遇伪装；

**查明对手的证书：SSL**

（3）无法验证报文的完整性，可能遭遇篡改

**像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack,MITM）**

如何防止篡改？

**常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法**（这是在http中）

**7.2 http+加密+认证+完整性保护=https**

https只是http套了一层SSL，http先和SSL通信，再由SSL和TCP通信（TSL是以SSL为原型开发的协议，有时会统一称该协议为SSL，当前主流版本是SSL3.0和TSL1.0）

**https采用的是混合加密机制**

（1）SSL采用一种叫做公开密钥加密的加密处理方式

**共享密钥加密：加密和解密同用一个密钥的方式，也叫做对称密钥加密（不安全）**

**公开密钥加密：使用一对非对称的密钥，一把叫做私有密钥，另一把叫做公开密钥（处理速度慢）**

>即发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。

**混合加密：使用公开密钥加密方式传送后续共享密钥加密中要使用的密钥**

（2）如何证明公开密钥的正确性？

可以使用由数字证书认证机构（CA）和其他机关颁发的公开密钥证书

流程：

![image-20200228155417210](C:\Users\Lihang\AppData\Roaming\Typora\typora-user-images\image-20200228155417210.png)

https通信过程：

![image-20200310230631141](C:\Users\Lihang\AppData\Roaming\Typora\typora-user-images\image-20200310230631141.png)

（3）https的缺点：

通信时间延长；消耗大量CPU和内存，处理速度变慢；购买证书等导致成本变高

#### 8. 确认访问用户身份的认证

**8.1 HTTP/1.1使用的认证方式：**

（1）BASIC认证（基本认证）

（2）DIGEST认证（摘要认证）

（3）SSL客户端认证

（4）FormBase认证（基于表单认证）

**8.2 BASIC认证**

采用Base64编码方式，但不是加密处理；

想再进行一次BASIC认证时，一般的浏览器无法实现认证注销操作

**缺点：认证使用上不够灵活，且达不到多数网站期望的安全性等级，不常用**

**8.3 DIGEST认证**

客户端发送请求——服务器发送临时质询码（401）——客户端用MD5算法对质询码进行运算，并把密码字符串发给服务器端（认证成功：200；认证失败：401）

**DIGEST认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制**

**8.4 SSL客户端认证**

认证步骤：

（1）接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书；

（2）用户选择要发送的客户端证书后，客户端会把客户端证书以Client Certificate报文方式发给服务器；

（3）服务器验证客户端证书通过后可领取证书中的公开密钥，然后开始HTTPS加密通信

**SSL客户端认证采用SSL客户端认证（用于认证客户端计算机）和基于表单认证双因素认证（用于认证用户本人身份）**

**8.5 基于表单认证**

session管理和cookie应用：

使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送；

cookie中的Session ID用于识别用户

**服务器端如何保存客户端发来的用户名和密码？**

一种安全的保存方式是：先利用给密码加盐（salt:加随机生成的字符串）的方式增加额外信息（避免密码相同），再使用散列（hash）函数计算出散列值后保存

**8.6 session（会话）管理及cookie应用**

![image-20200310234233723](C:\Users\Lihang\AppData\Roaming\Typora\typora-user-images\image-20200310234233723.png)

#### 9. 基于http的功能追加协议

**9.1 消除HTTP瓶颈的SPDY：旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间**

>HTTP瓶颈：
>
>（1）一条连接上只可发送一个请求
>
>（2）请求只能从客户端开始。客户端不可以接收除响应以外的指令
>
>（3）请求/响应首部未经压缩就发送。首部信息越多延迟越大
>
>（4）发送冗长的首部。每次互相发送相同的首部造成的浪费较多
>
>（5）可任意选择数据压缩格式。非强制压缩发送

**9.1.1 Ajax的解决方法：局部Web页面替换加载的异步通信手段**

核心技术：XMLHttpRequest:可以从已加载完毕的Web页面上发起请求，只更新局部页面

**9.1.2 Comet的解决方法：对于客户端发送的确认更新情况的请求，服务器端会将响应保留到有内容更新**

>但Ajax和Comet方法都没有解决http协议本身存在的问题：每次都互相发送相同的首部，有时不压缩数据直接发送。

**9.1.3 SPDY：**

目标：为了对http进行从根本上的改善，需要有一些协议层面上的改动

SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。

![image-20200312105726881](C:\Users\Lihang\AppData\Roaming\Typora\typora-user-images\image-20200312105726881.png)

**使用SPDY后，HTTP协议额外获得以下功能：**

>（1）多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求
>
>（2）赋予请求优先级：为了在发送多个请求时，解决因带宽低而导致响应变慢的问题
>
>（3）压缩HTTP首部：
>
>（4）推送功能：支持服务器主动向客户端推送数据的功能
>
>（5）服务器提示功能：服务器可以主动提示客户端请求所需的资源

**9.2 使用浏览器进行全双工通信的WebSocket**

主要特点：

>（1）推送功能
>
>（2）减少通信量：只要建立起WebSocket通信，就希望一直保持连接状态，和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了

**为了实现WebSocket通信，在HTTP连接建立以后，需要完成一次“握手”的步骤**

>握手_请求：
>
>Upgrade: websocket
>
>Connection: Upgrade
>
>Sec-WebSocket-Key: 记录握手过程中必不可少的键值
>
>Sec-WebSocket-Protocol: 记录使用的子协议
>
>握手_响应：
>
>状态行： HTTP/1.1 101 Switching Protocols
>
>Upgrade: websocket
>
>Connection: Upgrade
>
>Sec-WebSocket-Accept: 由握手请求中的Sec-WebSocket-Key的字段值生成
>
>Sec-WebSocket-Protocol: 

![image-20200312122312572](C:\Users\Lihang\AppData\Roaming\Typora\typora-user-images\image-20200312122312572.png)

**9.3 HTTP/2.0:目标是改善用户在使用Web时的速度体验**

以以下协议为基础：

>SPDY:
>
>HTTP Speed + Mobility：用于改善并提高移动端通信时的通信速度和性能
>
>Network-Friendly HTTP Upgrade：在移动端通信时改善HTTP性能

HTTP/2.0 的7项技术和讨论

![image-20200312124716664](C:\Users\Lihang\AppData\Roaming\Typora\typora-user-images\image-20200312124716664.png)

**9.4 Web服务器管理文件的WebDAV：**

一个可对服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统，除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能

#### 10. 构建web内容的技术

**10.1 web应用**

CGI：通用网关接口：是指Web服务器在接收到客户端发来的请求后转发给程序的一组机制

![image-20200312130504383](C:\Users\Lihang\AppData\Roaming\Typora\typora-user-images\image-20200312130504383.png)

#### 11. web的攻击技术

##### 11.1 针对Web的攻击技术

针对Web应用的攻击模式有以下两种：

>**主动攻击：是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式**
>
>具有代表性的：SQL注入攻击和OS命令注入攻击
>
>**被动攻击：是指利用圈套策略执行攻击代码的攻击模式。在被攻击过程中，攻击者不直接对目标Web应用访问发起攻击**
>
>具有代表性的：跨站脚本攻击（XSS），跨站点请求伪造
>
>![Web被动攻击流程图](.\image\Web被动攻击流程图.png)

##### 11.2  因输出值转义不完全引发的安全漏洞

![验证数据的几个地方](.\image\验证数据的几个地方.png)

>**实施Web应用的安全对策可大致分为以下两部分：**
>
>（1）客户端的验证：只是为了尽早辨识输入错误，提高UI体验
>
>（2）Web应用端（服务器端）的验证：
>
>输入值验证:通常是指检查是否是符合系统业务逻辑的数值或检查字符编码等预防对策
>
>输出值转义：当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害。

**11.2.1 跨站脚本攻击：XSS：是攻击者利用预先设置的陷阱触发的被动攻击**

是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的html 标签或JS进行的一种攻击

>**XSS有可能造成以下影响：**
>
>（1）利用虚假输入表单骗取用户个人信息（如在输入框中输入`<script>`脚本）
>
>（2）利用脚本窃取用户的Cookie值，被害者在不知情的情况下帮助攻击者发送恶意请求
>
>（3）显示伪造的文章或图片

**11.2.2 SQL注入攻击**

>SQL注入攻击有可能会造成以下等影响：
>
>（1）非法查看或篡改数据库内的数据；
>
>（2）规避认证
>
>（3）执行和数据库服务器业务关联的程序等
>

**11.2.3 OS命令注入攻击：是指通过Web应用，执行非法的操作系统命令达到攻击的目的**



